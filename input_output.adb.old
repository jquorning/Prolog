--  Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992 by the Program
--  Analysis and Verification Group, Leland Stanford Junior University.
--  All Rights Reserved.
--
--  This file is part of the Anna tools.  You may copy, modify, and
--  distribute the Anna tools under the conditions described in the Anna
--  General Public License.  A copy of this license should be in a file
--  named COPYING.
--
--  LELAND STANFORD JUNIOR UNIVERSITY ALLOWS FREE USE OF THIS SOFTWARE IN
--  ITS "AS IS" CONDITION.  LELAND STANFORD JUNIOR UNIVERSITY DISCLAIMS
--  ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM
--  THE USE OF THIS SOFTWARE.
----------------------------------------------------------------------

with Ada.Text_Io;    use Ada.Text_Io;
with Prolog_Errors;  use Prolog_Errors;
with Error_Pkg;      use Error_Pkg;


package body Input_Output is


    System_Mode : Boolean := False;
    --  Is a system file being seen at present?

    Linelisted : Boolean := False;
    --  Has the current line been listed?

    Maxlength : constant := 200;
    --  Maximum length of an input line and output buffer.

    type Input_File_Array  is array (1 .. Maxindepth)  of File_Type;
    type Output_File_Array is array (1 .. Maxoutdepth) of File_Type;

    Input  : Input_File_Array;
    Output : Output_File_Array;
    --  Input and output files.

    Prolib : File_Type;
    --  Input files for system.

    --  All about input.

    subtype Inbufftype is String(1 .. Maxlength);
    subtype Inrange is Integer range 0 .. Maxlength;

    In_Line_Buff : array (1 .. Maxindepth)
                     of Inbufftype := (others => Inbufftype'(others => ' '));
    --  Buffer for current input line.
    --  This can be from either files, or from within the program via Set_String


    Charpos : array (1 .. Maxindepth) of Inrange := (others => 0);
    --  Position in current input line.
  

    Inlinelength : array (1 .. Maxindepth) of Inrange := (others => 0);
    --  Length of current input line.


    type Acc is access String;
    Remaining_Input  : Acc := null;
    Collected_Output : Acc := null;

    subtype Outrange is Natural range 0 .. Rightmargin;

    Outlinelength : array (1 .. Maxoutdepth) of Outrange := (others => 0);
    --  Positions in the current output lines. One value for each file
    --  in the variable "output"

    Templength    : array (1 .. Maxoutdepth) of Outrange := (others => 0);
    --  Position in the output buffer.

    Outlinebuff   : array (1 .. Maxoutdepth) of Inbufftype
                            := (others => Inbufftype'(others => ' '));
    --  The output line.

    Tempbuff      : array (1 .. Maxoutdepth) of Inbufftype
                            := (others => Inbufftype'(others => ' '));
    --  The output buffer.

    Seeflag, Tellflag : Boolean;
    --  Is a file being seen/told?


--  Input files are double buffered so that helpful syntax error messages 
--  can be produced.  Listing of the input text is controlled by the
--  variable 'listing'.


--  The input/ output of a line is organized around the global vars:
--  maxoutdepth which is max depth to which files can be 'told'. 
--  maxindepth which is max depth to which files can be 'seen'. 
--  However changing maxout/indepth is not enough to increase
--  the depth. All associated procedures in this package have to be 
--  changed.
--  The input and output lines can be of Maxlength length but
--  to list errors by printing out lines and put a cursor '^' at
--  the place of error we should print out long lines in pieces of
--  the tty width which is the constant RightMargin.
--  The arrays OutlineBuff and In_Line_Buff hold lines for each of
--  the out/infiledepth files. 
--  The lengths of these are given in the arrays In/OutlineLength.
--  To implement the sort of error reporting outlined earlier
--  the buffer TempLine is used. Notice this only has length rightmargin.
--  the files output,output1-outfiledepth and input,input1-infiledepth
--  are used.
--  linelisted is set when the present line has been listed. 
--  mode is userM,progM,sysM.
--  This implies user,program(init) or system mode.
--  online is on when the input is being given online.


procedure Init_Input is
begin
   In_File_Depth := 1;
   Inlinelength (1) := 0;
   Charpos (In_File_Depth) := 0;
end;

--  Write out : ------------------------------------------------------

procedure Init_String is
begin
    Collected_Output := null;
end;

function Get_String return String is
begin
    return Collected_Output.all;
end;

procedure Putline is
    --  simply puts line physically on the output file given by
    --  outfiledepth ands updates Outlinelength.

    Len  : Integer renames Outlinelength (Out_File_Depth);
    Str  : String  renames Outlinebuff (Out_File_Depth);

begin

    if Out_File_Depth = 1 then
        if Collected_Output = null then
            --  *** dispose (collected_output);
            Collected_Output := new String'(Str(1 .. Len));

        else
            --  *** dispose (collected_output);
            Collected_Output := new String'(Collected_Output.all
                                            & Str (1 .. Len)
                                           );

        end if;
        --  PUT_LINE(OUTLINEBUFF(OUTFILEDEPTH)(1 .. OUTLINELENGTH(OUTFILEDEPTH)));
    else
        Put_Line (Output(Out_File_Depth), Str (1 .. Len));
    end if;

    Len := 0;

end Putline;



procedure Wrcheck is
   --checks if tempbuff is overflowing and outputs if it is.
    Len      : Integer renames Outlinelength (Out_File_Depth);
    Temp_Len : Integer renames Templength (Out_File_Depth);
    Str      : String  renames Outlinebuff (Out_File_Depth);

begin
    if Len + Temp_Len > Rightmargin then
        Putline;
    end if;

    Str (Len + 1 ..  Len + Temp_Len) := Tempbuff(Out_File_Depth)(1 .. Temp_Len);

    Len := Len + Temp_Len;

    Temp_Len := 0;

end Wrcheck;

procedure Wrln is
   --output present line
begin
    Wrcheck;
    Putline;
end Wrln;

procedure Wr(Ch: Character) is
   --put character in output buffer
begin
    --  This should never happen.
    --  if TEMPLENGTH(OUTFILEDEPTH) >= RIGHTMARGIN then
    --     WRLN;
    --  end if;

    Templength(Out_File_Depth) := Templength(Out_File_Depth) + 1;
    Tempbuff(Out_File_Depth)(Templength(Out_File_Depth)) := Ch;
end Wr;

procedure Wrint(N: Integer) is
    --put an integer in the output buffer
    Str : constant String := Integer'Image(N);
begin
   if N < 0 then
       Wrstring(Str);
   else
       --  get rid of the leading space.
       for I in 2 .. Str'Length loop
           Wr(Str(I));
       end loop;
   end if;
end Wrint;

procedure Wrstring(S : String) is
   --this just outputs a string character by character
begin
   for I in S'range loop
       Wr(S(I));
   end loop;

end Wrstring;


procedure Listline is
   --  List the current line.
   --  the input line may be larger than output line, hence the tricks.
   --  max input line length is maxlength
   --  max output line length is rightmargin
begin
    for I in 1 .. Inlinelength(In_File_Depth) - 1 loop
        if ((I mod Rightmargin) = 0) then
            Wrln;
        end if;
        --  write out each time output buffer line i.e.tempbuff becomes full.
        Wr(In_Line_Buff(In_File_Depth)(I));
    end loop;
    Wrln;
    Linelisted := True;
    --  linelisted is a boolean showing whether the present line has been listed.
end Listline;


--  Read in : -------------------------------------------------------

procedure Set_String(S : String) is
    Length : Integer;
begin
    if S'Length >= Maxlength then
        Length := Maxlength-1;
        In_Line_Buff(1)(1 .. Length) := S(S'First .. (S'First+Length-1));
        Inlinelength(1) := Length;

        --  *** dispose (remaining_input)
        Remaining_Input := new String'(S(Maxlength .. S'Last));
        Charpos(1) := 0;
    else
        Length := S'Length;
        Inlinelength(1) := Length + 1;
        In_Line_Buff(1)(1 .. Length) := S(S'First .. (S'First+Length-1));
        In_Line_Buff(1)(Length+1) := ' ';
        Charpos(1) := 0;
    end if;
end Set_String;


procedure Getline(F : File_Type) is
    --  Get the next line from file 'f' in 'linebuf'.
begin
    if ((System_Mode) or (Seeflag)) and then  End_Of_File(F) then
        Moan(Eof_Error, Diez);
   end if;

   Charpos(In_File_Depth) := 0;
   Linelisted := False;

   --  Initialize
   if (not System_Mode) and (not (Seeflag)) then
      null;
      --GET_LINE(INLINEBUFF(INFILEDEPTH),INLINELENGTH(INFILEDEPTH));
   else
      Get_Line (F,In_Line_Buff (In_File_Depth), Inlinelength (In_File_Depth));
   end if;

   if Inlinelength (In_File_Depth) >= Maxlength then --  This will never happen.
       Moan (Long_Line_Error, Diez);
   end if;

   Inlinelength (In_File_Depth) := Inlinelength (In_File_Depth) + 1;
   In_Line_Buff (In_File_Depth)(Inlinelength (In_File_Depth)) := ' ';

   if Listing then
       Listline;
   end if;

exception
   when End_Error =>
      Charpos (In_File_Depth):=0;
      Linelisted := False;
      In_Line_Buff (In_File_Depth)(1):=' ';
      Inlinelength (In_File_Depth):=1;

end Getline;


procedure Checkline is
   --  Ensure that the line in 'linebuf' is not exhausted.
   --  the next char to be read, given by charpos should point
   --  to within the buffer,if not get next line.
begin
   if Charpos(In_File_Depth) >= Inlinelength(In_File_Depth) then
       if Seeflag then
           if In_File_Depth < Maxindepth then
               Getline(Input(In_File_Depth));
           end if;

       elsif System_Mode then
               Getline(Prolib);

       elsif Remaining_Input = null then
           put_line ("Input_output error");
           Moan(Eof_Error,Syntaxz);

       else
           Set_String(Remaining_Input.all);
       end if;
   end if;
end Checkline;


function Getchar return Character is
    --  Get the next character of the current input file in 'ch'.
   Ch : Character;
begin
   Checkline;
   Charpos(In_File_Depth) := Charpos(In_File_Depth) + 1;

   Ch := In_Line_Buff (In_File_Depth)(Charpos (In_File_Depth));
   if Debug then
      put ('#');
      Put(ch);
   end if;
   return Ch;

end Getchar;


function Line_Ended return  Boolean is
   --remember charpos points to one less than the next char to be read
begin
   Checkline;
   return Charpos(In_File_Depth)  = Inlinelength(In_File_Depth)  - 1;
end Line_Ended;


function File_Ended_Internal return Boolean is
   result : boolean;
begin
   If debug then 
      put_line ("FE Internal");
   end if;

   if In_File_Depth < Maxindepth then
       if In_File_Depth = 1 then
           Put_Line ("File_Ended, In file depth =1");
           return False;
       else
           result := End_Of_File (Input(In_File_Depth));
           if debug then
              put_Line ("end of file reached");
           end if;
           return result;
           --  return End_Of_File (Input(In_File_Depth));
       end if;
   end if;
   raise Program_Error;
end File_Ended_Internal;


function File_Ended return  Boolean is
begin
   If debug then 
      put_line ("FE");
   end if;
    
    if Charpos(In_File_Depth) < Inlinelength(In_File_Depth) then 
        return False;

    elsif Seeflag then
        if debug then
           put("seeflag");
        end if;
        return File_Ended_Internal;
        --seeflag is on when some user file is being read
    else
        if debug then
           put_line ("else, FE");
        end if;

        if System_Mode then
            if debug then
                put_Line ("system mode");
            end if;
            return End_Of_File(Prolib);
        else
            put_line ("about to return false");
            return False;
        end if;

    end if;

end File_Ended;

--  File Stuff : -----------------------------------------------------

function Seefile(Filename : String) return Boolean is
   --  Evaluable predicate 'see'. Open a file for reading.
   Dummy : Boolean;
begin
    if In_File_Depth < Maxindepth then
        In_File_Depth:= In_File_Depth+1;
        Open(Input(In_File_Depth),In_File,Filename);
        Seeflag:= True;
        System_Mode := False;
        if File_Ended then
            Dummy := Seenfile;
            return False;
        end if;
        return True;
    else
        Moan(In_File_Depth_Error, Abortz);
    end if;
    raise Program_Error;
exception
    when Status_Error =>
        Moan(File_Status_Error,Abortz);
        pragma Assert (False);
        raise Program_Error;

    when Name_Error =>
        Moan(File_Name_Error,Abortz);
        pragma Assert (False);
        raise Program_Error;

    when others =>
        raise;
end Seefile;

function Tellfile(Filename : String) return Boolean is
   --  Evaluable predicate 'tell'. Open a file for writing.
begin
    if Out_File_Depth < Maxoutdepth then
        Out_File_Depth:= Out_File_Depth+1;
        Create(Output(Out_File_Depth),Out_File,Filename);
        Tellflag:= True;
        return True;
    else
        Moan(Out_File_Depth_Error, Abortz);
    end if;

    pragma Assert (False);
    raise Program_Error;

exception
    when Status_Error =>
        Moan(File_Status_Error,Abortz);
        pragma Assert (False);
        raise Program_Error;

    when Name_Error =>
        Moan(File_Name_Error,Abortz);
        pragma Assert (False);
        raise Program_Error;

    when others =>
        raise;
end Tellfile;

function Seeingfile return Boolean is
begin
    return Seeflag;
end Seeingfile;

function Tellingfile return Boolean is
begin
    return Tellflag;
end Tellingfile;

function Seenfile return Boolean is 
begin
    if (In_File_Depth > 1) then
        if Is_Open(Input(In_File_Depth)) then 
            Close(Input(In_File_Depth)); 
        end if;
        In_File_Depth := In_File_Depth-1;
        Seeflag:= (In_File_Depth > 1);
        return True;
    else
        Seeflag:= False;
        return False;
    end if;
end Seenfile;

function Toldfile return Boolean is
begin
    if (Out_File_Depth > 1) then
        Wrln;
        if Is_Open(Output(Out_File_Depth)) then 
            Close(Output(Out_File_Depth)); 
        end if;
        Out_File_Depth := Out_File_Depth-1;
        Tellflag:= (Out_File_Depth > 1);
        return True;
    else
        Tellflag:= False;
        return False;
    end if;
end Toldfile;

function Seesystemfile(Filename : String) return Boolean is
    --  Open a systemfile for reading.
begin
    Open(Prolib,In_File,Filename);
    System_Mode := True;
    
    return True;
exception
    when others =>
	return False;
end;

function Seeingsystemfile return Boolean is
begin
   return Is_Open(Prolib);
end;

function Seensystemfile return Boolean is
begin
   if Is_Open(Prolib) then
       Close(Prolib);
       System_Mode := False;
       return True;
   else
       return False;
   end if;
end;

begin

   In_File_Depth:=1;
   Out_File_Depth:=1;
   Outlinelength (Out_File_Depth) := 0;
   Templength (Out_File_Depth) := 0;

end Input_Output;
